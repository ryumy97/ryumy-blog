---
title: "표"
description: "데이터를 남에게 설명하자."
date: "2025-08-31"
category: ["fundamentals", "data-visualization"]
tags: ["표", "기본요소", "시각화", "canvas"]
image: "/images/dots-visualization.jpg"
---

# 표

표를 만드는 이유는 데이터를 시각화하여 남에게 보여주기 위함입니다.

표는 데이터를 남에게 설명하려면 그 전의 에시보다 더 많은 정보를 보여줘야 합니다.

예를들어 전의 "점"을 표현하는 코드는 캔버스위에 점을 올려놓았을뿐 그것이 그 점을 바라보고 있는 사용자에게는 아무 의미가 없습니다.
그 점들이 버튼과의 상관관계의 설명도 부족하였습니다.

## 축

표에 가장 중요한 첫번째 요소는 축입니다. 축은 데이터의 위치와 값의 관계를 나타냅니다.
보통 많이 보듯이 2차원의 좌표평면 위에 데이터를 표현할때 x축 y축으로 나누어 사용합니다.

만약에 x축 범위가 0 부터 100 까지 표기가 있고, y축이 0 부터 100 까지 표기가 있고,
표 중심에 데이터를 표기하는 점 하나가 찍혀있다면
x축 중간값과 y축 중간값을 나타네는 데이터, 즉 데이터의 값은 50, 50 이라는 의미가 된다.

하지만 어떻게 사용자는 값이 50, 50인 데이터를 정확히 알 수 있을까? 애매한 수 49, 49 일 수 도 있는것 아닌가?
그것을 시각적으로 돕기위해 축에는 눈금이 있고, 눈금을 기준으로 그리드 선을 그릴 수 있다.

그럼 이제 축을 한번 그려보자.

<CodeRunner
  title="표 - 1"
  height={560}
  files={[
    {
      type: "html",
      path: "index.html",
      content: `
      <!DOCTYPE html>
      <html>
        <body>
          <div class="container">
            <h1>표 - 1</h1>
            <canvas id="chart-1"></canvas>
          </div>
        </body>
      </html>
      `
    },
    {
      type: "css",
      path: "styles.css",
      content: `
      .container {
        padding: 20px;
        text-align: center;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 20px;
      }
      canvas {
        border: 1px solid #ccc;
      }
      button {
        padding: 10px 20px;
        background-color: #007bff;
        color: white;
        border: none;
        cursor: pointer;
      }
      `
    },
    {
        type: 'js',
        path: 'renderer.js',
        content: `
        export default class Renderer {
          constructor(canvas) {
            this.canvas = canvas;
            this.ctx = canvas.getContext('2d');
            this.components = [];
          }

          register(component) {
            this.components.push(component);
          }

          draw() {
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            this.components.forEach(component => component.draw(this.ctx));
          }
        }
        `
    },
    {
      type: "js",
      path: "position.js",
      content: `
      export default class Position {
        constructor(x, y) {
          this.x = x;
          this.y = y;
        }

        draw(ctx) {
          ctx.strokeStyle = 'steelblue';
          ctx.beginPath();
          ctx.ellipse(this.x, this.y, 5, 5, 0, 0, 2 * Math.PI);
          ctx.closePath();
          ctx.stroke();
        }
      }
      `
    },
    {
        type: 'js',
        path: 'axis.js',
        content: `
        export default class Axis {
          constructor(type, valueRange, displayRange) {
            this.type = type;
            this.valueRange = valueRange;
            this.displayRange = displayRange;

            {/* 캔버스 세팅 값 */}
            this.canvasHeight = 300;
            this.margin = 20;

            {/* 눈금 간격 */}
            this.tick = 10;
          }

          linearTransform(value) {
            return (value - this.valueRange[0]) / (this.valueRange[1] - this.valueRange[0]) * (this.displayRange[1] - this.displayRange[0]) + this.displayRange[0];
          }

          draw(ctx) {
            ctx.strokeStyle = 'gray';
            ctx.beginPath();

            if (this.type === 'x') {
              ctx.moveTo(this.displayRange[0], this.canvasHeight - this.margin);
              ctx.lineTo(this.displayRange[1], this.canvasHeight - this.margin);
            }
            else {
              ctx.moveTo(this.margin, this.displayRange[0]);
              ctx.lineTo(this.margin, this.displayRange[1]);
            }

            ctx.closePath();
            ctx.stroke();



            for (let i = this.valueRange[0]; i <= this.valueRange[1]; i += this.tick) {
              const tickValue = this.valueRange[0] + i;

              const text = ctx.measureText(tickValue);
              const textWidth = text.width;
              const textHeight = text.height;

              if (this.type === 'x') {
                ctx.strokeStyle = 'gray';
                ctx.beginPath();
                ctx.moveTo(this.linearTransform(i), this.canvasHeight - this.margin);
                ctx.lineTo(this.linearTransform(i), this.canvasHeight - this.margin + 5);

                ctx.fillText(
                  tickValue,
                  this.linearTransform(i) - textWidth / 2,
                  this.canvasHeight - this.margin + 15
                );

                ctx.closePath();
                ctx.stroke();
              }
              else {
                ctx.strokeStyle = 'gray';
                ctx.beginPath();
                ctx.moveTo(this.margin, this.linearTransform(i));
                ctx.lineTo(this.margin - 5, this.linearTransform(i));


                ctx.fillText(
                  tickValue,
                  this.margin - textWidth - 6,
                  this.linearTransform(i) + 3
                );

                ctx.closePath();
                ctx.stroke();
              }
            }

          }
        }
        `
    },
    {
      type: "js",
      path: "index.js",
      content: `
      import "./styles.css";
      import Position from './position.js';
      import Renderer from './renderer.js';
      import Axis from './axis.js';

      const canvas = document.getElementById('chart-1');
      const ctx = canvas.getContext('2d');

      canvas.width = 300;
      canvas.height = 300;

      const axisX = new Axis('x', [0, 100], [20, 280]);
      const axisY = new Axis('y', [0, 100], [20, 280]);

      const positions = [
        new Position(10, 10),
        new Position(20, 20),
        new Position(30, 30),
        new Position(40, 40),
        new Position(50, 50),
      ];

      const renderer = new Renderer(canvas);

      renderer.register(axisX);
      renderer.register(axisY);
      positions.forEach(position => renderer.register(position));

      renderer.draw();
      `
    }

]}

/>

Renderer 클라스에 무엇을 그릴지 저장하는 register 메소드를 추가했다.
Axis 클라스와 Position 클라스는 모두 캠버스 위를 그리는 함수를 가지고 있고, 이를 통해 같은 형태를 지니는 클라스들을 하나의 형태로 관리할 수 있게 되었다.

하지만 위 예시는 무언가 잘못된 부분이 있다. 그것은 무엇일까.

## 데이터 위치와 값

Position 클라스의 데이터는 x, y 좌표라는 데이터를 가지고 있다. 허나 위 예시를 보먄 축이 있기 때분에 Position의 x, y 좌표를 그대로 옮겨 캔버스에 그리면
사용자에게 보여지는 데이터의 위치는 축의 눈금과 상관없이 캔버스 위에 그려지게 된다.

이런 문제를 해결하기 위해 Renderer 클라스의 구조를 바꿔보자.

<CodeRunner
  title="표 - 2"
  height={560}
  files={[
    {
      type: "html",
      path: "index.html",
      content: `
      <!DOCTYPE html>
      <html>
        <body>
          <div class="container">
            <h1>표 - 2</h1>
            <canvas id="chart-2"></canvas>
          </div>
        </body>
      </html>
      `
    },
    {
      type: "css",
      path: "styles.css",
      content: `
      .container {
        padding: 20px;
        text-align: center;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 20px;
      }
      canvas {
        border: 1px solid #ccc;
      }
      button {
        padding: 10px 20px;
        background-color: #007bff;
        color: white;
        border: none;
        cursor: pointer;
      }
      `
    },
    {
        type: 'js',
        path: 'renderer.js',
        content: `
        export default class Renderer {
          constructor(canvas, xTransformer, yTransformer) {
            this.canvas = canvas;
            this.ctx = canvas.getContext('2d');

            this.components = [];
            this.transformers = {
              x: xTransformer,
              y: yTransformer,
            }
          }

          register(component) {
            this.components.push(component);
          }

          draw() {
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            this.components.forEach(component => component.draw(this.ctx, this.transformers));
          }
        }
        `
    },
    {
      type: "js",
      path: "position.js",
      content: `
      export default class Position {
        constructor(x, y) {
          this.x = x;
          this.y = y;
        }

        draw(ctx, transformers) {
          ctx.fillStyle = 'steelblue';
          ctx.beginPath();
          ctx.ellipse(transformers.x.linearTransform(this.x), transformers.y.linearTransform(this.y), 3, 3, 0, 0, 2 * Math.PI);
          ctx.closePath();
          ctx.fill();
        }
      }
      `
    },
    {
        type: 'js',
        path: 'axis.js',
        content: `
        export default class Axis {
          constructor(type, valueRange, tick) {
            this.type = type;

            {/* 캔버스 세팅 값 */}
            this.canvasHeight = 300;
            this.margin = 20;

            {/* 눈금 간격 */}
            this.valueRange = valueRange;
            this.tick = tick;
          }

          draw(ctx, transformers) {
            ctx.strokeStyle = 'gray';
            ctx.beginPath();

            if (this.type === 'x') {
              const start = transformers.x.linearTransform(this.valueRange[0]);
              const end = transformers.x.linearTransform(this.valueRange[1]);

              ctx.moveTo(start, this.canvasHeight - this.margin);
              ctx.lineTo(end, this.canvasHeight - this.margin);
            }
            else {
              const start = transformers.y.linearTransform(this.valueRange[0]);
              const end = transformers.y.linearTransform(this.valueRange[1]);

              ctx.moveTo(this.margin, start);
              ctx.lineTo(this.margin, end);
            }

            ctx.closePath();
            ctx.stroke();

            for (let i = this.valueRange[0]; i <= this.valueRange[1]; i += this.tick) {
              const tickPosition = transformers[this.type].linearTransform(i);

              ctx.strokeStyle = 'gray';
              ctx.beginPath();

              if (this.type === 'x') {
                ctx.moveTo(tickPosition, this.canvasHeight - this.margin);
                ctx.lineTo(tickPosition, this.canvasHeight - this.margin + 5);

                ctx.closePath();
                ctx.stroke();

                const text = ctx.measureText(i);
                const textWidth = text.width;

                ctx.fillStyle = 'gray';
                ctx.fillText(
                  i,
                  tickPosition - textWidth / 2,
                  this.canvasHeight - this.margin + 15
                );
              } else {
                ctx.moveTo(this.margin, tickPosition);
                ctx.lineTo(this.margin - 5, tickPosition);

                ctx.closePath();
                ctx.stroke();

                const text = ctx.measureText(i);
                const textWidth = text.width;

                ctx.fillStyle = 'gray';
                ctx.fillText(
                  i,
                  this.margin - textWidth - 6,
                  tickPosition + 3
                );
              }
            }

          }
        }
        `
    },
    {
      type: "js",
      path: "transformer.js",
      content: `
      export default class Transformer {
        constructor(valueRange, displayRange) {
          this.valueRange = valueRange;
          this.displayRange = displayRange;
        }

        linearTransform(value) {
          return (value - this.valueRange[0]) / (this.valueRange[1] - this.valueRange[0]) * (this.displayRange[1] - this.displayRange[0]) + this.displayRange[0];
        }
      }
      `
    },
    {
      type: "js",
      path: "index.js",
      content: `
      import "./styles.css";
      import Position from './position.js';
      import Renderer from './renderer.js';
      import Axis from './axis.js';
      import Transformer from './transformer.js';

      const canvas = document.getElementById('chart-2');
      const ctx = canvas.getContext('2d');

      canvas.width = 300;
      canvas.height = 300;

      const valueRange = [0, 100];

      const xTransformer = new Transformer(valueRange, [20, 280]);
      const yTransformer = new Transformer(valueRange, [280, 20]);

      const axisX = new Axis('x', valueRange, 10);
      const axisY = new Axis('y', valueRange, 10);

      const positions = [
        new Position(10, 10),
        new Position(20, 20),
        new Position(30, 30),
        new Position(40, 40),
        new Position(50, 50),
      ];

      const renderer = new Renderer(
        canvas,
        xTransformer,
        yTransformer
      );

      renderer.register(axisX);
      renderer.register(axisY);
      positions.forEach(position => renderer.register(position));

      renderer.draw();
      `
    }

]}

/>

Renderer 쿨라스는 이제 x, y 축의 트랜스포머를 받아 그림을 그릴때에 x와 y의 데이터 위치를 캔버스상의 위치로 변환할 수 있게 되었다.
위의 에시를 보면 xTransformer와 yTransformer가 따로 존재하는것을 볼수있다.
xTransformer의 역할은 단순하다. 데이터 값 0부터 100까지가 있을때, 캔버스상 위치인 20 부터 280 까지로 변환하는 것이다.
yTransformer의 역할도 같다. 0부터 100까지의 값이 있을따 죄표 280부터 20까지로 변환하는 것이다.

이 두 transformer들은 Renderer 클라스가 draw 메소드를 호출할때에 사용되며, 데이터값을 표현할때 좌표값을 계산해주는 역할을 한다.

Position 클라스를 예로들면 x와 y 값을 그대로 출력하는것이 아니라, xTransformer와 yTransformer를 통해 캔버스상의 위치로 변환하여 출력하게 된다.

조금 더 발전시켜서 그리드를 그리게 하자.

<CodeRunner
  title="표 - 3"
  height={560}
  files={[
    {
      type: "html",
      path: "index.html",
      content: `
      <!DOCTYPE html>
      <html>
        <body>
          <div class="container">
            <h1>표 - 3</h1>
            <canvas id="chart-3"></canvas>
          </div>
        </body>
      </html>
      `
    },
    {
      type: "css",
      path: "styles.css",
      content: `
      .container {
        padding: 20px;
        text-align: center;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 20px;
      }
      canvas {
        border: 1px solid #ccc;
      }
      button {
        padding: 10px 20px;
        background-color: #007bff;
        color: white;
        border: none;
        cursor: pointer;
      }
      `
    },
    {
        type: 'js',
        path: 'renderer.js',
        content: `
        export default class Renderer {
          constructor(canvas, xTransformer, yTransformer) {
            this.canvas = canvas;
            this.ctx = canvas.getContext('2d');

            this.components = [];
            this.transformers = {
              x: xTransformer,
              y: yTransformer,
            }
          }

          register(component) {
            this.components.push(component);
          }

          draw() {
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            this.components.forEach(component => component.draw(this.ctx, this.transformers));
          }
        }
        `
    },
    {
      type: "js",
      path: "position.js",
      content: `
      export default class Position {
        constructor(x, y) {
          this.x = x;
          this.y = y;
        }

        draw(ctx, transformers) {
          ctx.fillStyle = 'steelblue';
          ctx.beginPath();
          ctx.ellipse(transformers.x.linearTransform(this.x), transformers.y.linearTransform(this.y), 3, 3, 0, 0, 2 * Math.PI);
          ctx.closePath();
          ctx.fill();
        }
      }
      `
    },
    {
        type: 'js',
        path: 'axis.js',
        content: `
        export default class Axis {
          constructor(type, valueRange, valueBase, tick) {
            this.type = type;

            {/* 눈금 간격 */}
            this.valueRange = valueRange;
            this.valueBase = valueBase;
            this.tick = tick;
          }

          draw(ctx, transformers) {
            ctx.strokeStyle = 'gray';
            ctx.beginPath();

            if (this.type === 'x') {
              const start = transformers.x.linearTransform(this.valueRange[0]);
              const end = transformers.x.linearTransform(this.valueRange[1]);

              const base = transformers.y.linearTransform(this.valueBase);

              ctx.moveTo(start, base);
              ctx.lineTo(end, base);

            }
            else {
              const start = transformers.y.linearTransform(this.valueRange[0]);
              const end = transformers.y.linearTransform(this.valueRange[1]);

              const base = transformers.x.linearTransform(this.valueBase);

              ctx.moveTo(base, start);
              ctx.lineTo(base, end);
            }

            ctx.closePath();
            ctx.stroke();

            for (let i = this.valueRange[0]; i <= this.valueRange[1]; i += this.tick) {
              const tickPosition = transformers[this.type].linearTransform(i);

              const base = transformers[this.type === 'x' ? 'y' : 'x'].linearTransform(this.valueBase);


              ctx.strokeStyle = 'gray';
              ctx.beginPath();

              if (this.type === 'x') {
                ctx.moveTo(tickPosition, base);
                ctx.lineTo(tickPosition, base + 5);

                ctx.closePath();
                ctx.stroke();

                const text = ctx.measureText(i);
                const textWidth = text.width;

                ctx.fillStyle = 'gray';
                ctx.fillText(
                  i,
                  tickPosition - textWidth / 2,
                  base + 15
                );
              } else {
                ctx.moveTo(base, tickPosition);
                ctx.lineTo(base - 5, tickPosition);

                ctx.closePath();
                ctx.stroke();

                const text = ctx.measureText(i);
                const textWidth = text.width;

                ctx.fillStyle = 'gray';
                ctx.fillText(
                  i,
                  base - textWidth - 6,
                  tickPosition + 3
                );
              }
            }

          }
        }
        `
    },
    {
      type: "js",
      path: "transformer.js",
      content: `
      export default class Transformer {
        constructor(valueRange, displayRange) {
          this.valueRange = valueRange;
          this.displayRange = displayRange;
        }

        linearTransform(value) {
          return (value - this.valueRange[0]) / (this.valueRange[1] - this.valueRange[0]) * (this.displayRange[1] - this.displayRange[0]) + this.displayRange[0];
        }
      }
      `
    },
    {
        type: 'js',
        path: 'grid.js',
        content: `
        export default class Grid {
          constructor(xValueRange, yValueRange, xTick, yTick) {
            this.xValueRange = xValueRange;
            this.yValueRange = yValueRange;
            this.xTick = xTick;
            this.yTick = yTick;
          }

          draw(ctx, transformers) {
            for (let i = this.xValueRange[0] + this.xTick; i <= this.xValueRange[1]; i += this.xTick) {
              const x = transformers.x.linearTransform(i);

              const yMin = transformers.y.linearTransform(this.yValueRange[0]);
              const yMax = transformers.y.linearTransform(this.yValueRange[1]);

              ctx.strokeStyle = 'lightgray';
              ctx.beginPath();
              ctx.moveTo(x, yMin);
              ctx.lineTo(x, yMax);
              ctx.closePath();
              ctx.stroke();
            }


            for (let j = this.yValueRange[0] + this.yTick; j <= this.yValueRange[1]; j += this.yTick) {
              const y = transformers.y.linearTransform(j);

              const xMin = transformers.x.linearTransform(this.xValueRange[0]);
              const xMax = transformers.x.linearTransform(this.xValueRange[1]);

              ctx.strokeStyle = 'lightgray';
              ctx.beginPath();
              ctx.moveTo(xMin, y);
              ctx.lineTo(xMax, y);
              ctx.closePath();
              ctx.stroke();
            }
          }
        }
        `
    },
    {
      type: "js",
      path: "index.js",
      content: `
      import "./styles.css";
      import Position from './position.js';
      import Renderer from './renderer.js';
      import Axis from './axis.js';
      import Grid from './grid.js';
      import Transformer from './transformer.js';

      const canvas = document.getElementById('chart-3');
      const ctx = canvas.getContext('2d');

      // 세팅
      canvas.width = 300;
      canvas.height = 300;

      const valueRange = [0, 100];

      // 트랜스포머
      const xTransformer = new Transformer(valueRange, [20, 280]);
      const yTransformer = new Transformer(valueRange, [280, 20]);

      // 컴포넌트
      const axisX = new Axis('x', valueRange, 0, 10, true);
      const axisY = new Axis('y', valueRange, 0, 10, true);

      const grid = new Grid(valueRange, valueRange, 10, 10);

      const positions = [
        new Position(10, 10),
        new Position(20, 20),
        new Position(30, 30),
        new Position(40, 40),
        new Position(50, 50),
      ];

      // 렌더링
      const renderer = new Renderer(
        canvas,
        xTransformer,
        yTransformer
      );

      renderer.register(axisX);
      renderer.register(axisY);
      renderer.register(grid);
      positions.forEach(position => renderer.register(position));

      // 표현
      renderer.draw();
      `
    }

]}

/>

이제야 정상적인 표가 된것같다. 첫번째 점이 10, 10에 있다는것이 사용자에게 명확해졌다.

## 마무리

시각화를 만들때에는 가장 중요한것이 사용자다. 사용자가 이러한 시각화한것을 보고 데이터가 어떠한 의미를 지니는지가 가장 중요하다.
만약에 이러한 심플한 차트가 사용자에게 어떠한 정보도 담지못하면 무슨 소용이 있겠는가?

우리가 배운 축과 눈금이나 그리드 선들은 데이터와 위치를 설명하는 역할을 한다.
허나 이러한 축과 눈금이나 그리드 선들은 뿐만이 아니라 다른것들도 충분히 그 역할을 한때가 있다.
