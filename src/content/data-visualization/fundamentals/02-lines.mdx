---
title: "선"
description: "데이터가 많아졌다."
date: "2025-08-25"
category: ["fundamentals", "data-visualization"]
tags: ["선", "기본요소", "시각화", "canvas"]
image: "/images/dots-visualization.jpg"
---

# 선

두개의 데이터를 어떻게 표현해야 가장 좋을까?

사실 제목을 보고 선이라고 생각하기 쉽지만, 아쉽게도 점으로 표현하기가 쉽다.

데이터가 두개, x 와 y 라고 하면, 바로 생각나는것은 그래프 상의 점을 찍는것이다. 그럼 점을 찍는 코드를 작성해보자.

<CodeRunner
  title="선 - 1"
  height={460}
  files={[
    {
      type: "html",
      path: "index.html",
      content: `
      <!DOCTYPE html>
      <html>
        <body>
          <div class="container">
            <h1>선 - 1</h1>
            <canvas id="line-1"></canvas>
            <button id="button">버튼</button>
          </div>
        </body>
      </html>
      `
    },
    {
      type: "css",
      path: "styles.css",
      content: `
      .container {
        padding: 20px;
        text-align: center;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 20px;
      }
      canvas {
        border: 1px solid #ccc;
      }
      button {
        padding: 10px 20px;
        background-color: #007bff;
        color: white;
        border: none;
        cursor: pointer;
      }
      `
    },
    {
      type: "js",
      path: "index.js",
      content: `
      import "./styles.css";

      const canvas = document.getElementById('line-1');
      const ctx = canvas.getContext('2d');

      const button = document.getElementById('button');

      canvas.width = 200;
      canvas.height = 200;

      // 점 좌표를 저장하는 변수
      let x = 0;
      let y = 0;

      // 점 좌표를 무작위로 생성하는 함수
      function generateRandomData() {
        x = Math.random() * 200;
        y = Math.random() * 200;
      }

      // 점 데이터 생성
      generateRandomData();

      // 점 데이터 표현
      function drawDot(x, y) {
        ctx.fillStyle = 'steelblue';
        ctx.beginPath();
        ctx.ellipse(x, y, 10, 10, 0, 0, 2 * Math.PI);
        ctx.closePath();
        ctx.fill();
      }

      // 캔버스 랜더링
      function render() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawDot(x, y);
      }

      button.addEventListener('click', () => {
        // 점 데이터 제어한다.
        generateRandomData();

        // 점 데이터를 시간화 한다.
        render();
      });

      render();
      `
    }

]}
/>

위의 예시는 당신에게 너무 쉬울것이다. 저번에 배웠던 예시와 비슷하다.
캔버스가 있고, 점이라는 데이터를 그 위에 시각화 하는 코드를 작성한것이다.

다른점이 있다면 데이터가 두가지, x 와 y 좌표 값이라는것이다.

그럼 이제 선을 그려보자.

## 왜 선을 그릴까?

선은 두개의 점을 잇는 요소다. 즉, 두개의 정보의 관계을 표현한다.
두개의 점을 잇는 선을 그리기위해서는 두개의 점의 좌표가 필요하다.

만약에 x와 y값을 하나로 지정하고 그 0,0 이라는 기준점에서 부터 선을 그리면 0,0 기준점과 x,y 좌표의 관계 설명하는 표현을 하는것이다.

백터를 생각 해보라. 물리에서 사용하는 백터는 크기와 방향을 가지고 있는 데이터다.
0,0 기준점에서 부터 얼마나 크냐. 어떠한 방향으로 향하냐, 두가지의 정보를 가지고 있는 데이터다.
0,0의 기준점과 x,y 좌표의 관계를 설명하는 표현을 하는것이다.

## 선을 그리자.

<CodeRunner
  title="선 - 2"
  height={460}
  files={[
    {
      type: "html",
      path: "index.html",
      content: `
      <!DOCTYPE html>
      <html>
        <body>
          <div class="container">
            <h1>선 - 2</h1>
            <canvas id="line-2"></canvas>
            <button id="button">버튼</button>
          </div>
        </body>
      </html>
      `,
    },
    {
      type: "css",
      path: "styles.css",
      content: `
      .container {
        padding: 20px;
        text-align: center;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 20px;
      }
      canvas {
        border: 1px solid #ccc;
      }
      button {
        padding: 10px 20px;
        background-color: #007bff;
        color: white;
        border: none;
        cursor: pointer;
      }
      `,
    },
    {
      type: "js",
      path: "index.js",
      content: `
      import "./styles.css";

      const canvas = document.getElementById('line-2');
      const ctx = canvas.getContext('2d');

      const button = document.getElementById('button');

      canvas.width = 200;
      canvas.height = 200;

      // 좌표를 저장하는 변수
      let x = 0;
      let y = 0;

      // 좌표를 무작위로 생성하는 함수
      function generateRandomData() {
        x = Math.random() * 200;
        y = Math.random() * 200;
      }

      // 데이터 생성
      generateRandomData();

      // 라인 데이터 표현
      function drawLine(x, y) {
        ctx.strokeStyle = 'steelblue';
        ctx.beginPath();
        ctx.moveTo(0, 200);
        ctx.lineTo(x, 200 - y);
        ctx.closePath();
        ctx.stroke();
      }

      // 캔버스 랜더링
      function render() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawLine(x, y);
      }

      button.addEventListener('click', () => {
        // 데이터 제어한다.
        generateRandomData();

        // 데이터를 시간화 한다.
        render();
      });

      render();
      `,
    },

]}
/>

관계는 꼭 백터일 필요는 없다. 그냥 좌표상의 두 관계는 모두 선으로 표현될수 있다.
0,0 이라는 기준점을 사용하지 않고 점 두개를 사용해서 첫번째 점에서 두번째 점으로 잇는 코드를 생성해보자

<CodeRunner
  title="선 - 3"
  height={460}
  files={[
    {
      type: "html",
      path: "index.html",
      content: `
      <!DOCTYPE html>
      <html>
        <body>
          <div class="container">
            <h1>선 - 3</h1>
            <canvas id="line-3"></canvas>
            <button id="button">버튼</button>
          </div>
        </body>
      </html>
      `
    },
    {
      type: "css",
      path: "styles.css",
      content: `
      .container {
        padding: 20px;
        text-align: center;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 20px;
      }
      canvas {
        border: 1px solid #ccc;
      }
      button {
        padding: 10px 20px;
        background-color: #007bff;
        color: white;
        border: none;
        cursor: pointer;
      }
      `
    },
    {
      type: "js",
      path: "index.js",
      content: `
      import "./styles.css";

      const canvas = document.getElementById('line-3');
      const ctx = canvas.getContext('2d');

      const button = document.getElementById('button');

      canvas.width = 200;
      canvas.height = 200;

      // 좌표를 저장하는 변수 1
      let x = 0;
      let y = 0;

      // 좌표를 저장하는 변수 2
      let x2 = 0;
      let y2 = 0;

      // 좌표를 무작위로 생성하는 함수
      function generateRandomData() {
        x = Math.random() * 200;
        y = Math.random() * 200;

        x2 = Math.random() * 200;
        y2 = Math.random() * 200;
      }

      // 데이터 생성
      generateRandomData();

      // 라인 데이터 표현
      function drawLine(x, y, x2, y2) {
        ctx.strokeStyle = 'steelblue';
        ctx.beginPath();
        ctx.lineTo(x, 200 - y);
        ctx.lineTo(x2, 200 - y2);
        ctx.closePath();
        ctx.stroke();
      }

      // 캔버스 랜더링
      function render() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawLine(x, y, x2, y2);
      }

      button.addEventListener('click', () => {
        // 점 데이터 제어한다.
        generateRandomData();

        // 점 데이터를 시간화 한다.
        render();
      });

      render();
      `
    }

]}

/>

## 객체지향 프로그래밍

프론트 엔드 개발자라면 항상 범용성을 생각하며 코드를 작성하는것이 중요하다. 만약에 선이 2개가 아니라 3개가 필요하다면?
혹은 100개가 필요하다면? N개의 선을 이어서 그리는 코드를 생각해보자. 그러기 위해서는 변수를 깔끔하게 정리하는것이 중요하다.

변수 x, y를 하나의 그룹으로 생각하고, 변수 x2, y2를 하나의 그룹으로 생각하자.
클래스를 만들어 관리를 하면 같은 그룹의 변수를 하나의 객체로 관리할수 있다.

```js
class Position {
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }
}

class Line {
  constructor(position1, position2) {
    this.position1 = position1;
    this.position2 = position2;
  }
}
```

선 다섯개를 이어서 그리는 코드를 작성해보자.

<CodeRunner
  title="선 - 4"
  height={460}
  files={[
    {
      type: "html",
      path: "index.html",
      content: `
      <!DOCTYPE html>
      <html>
        <body>
          <div class="container">
            <h1>선 - 4</h1>
            <canvas id="line-4"></canvas>
            <button id="button">버튼</button>
          </div>
        </body>
      </html>
      `
    },
    {
      type: "css",
      path: "styles.css",
      content: `
      .container {
        padding: 20px;
        text-align: center;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 20px;
      }
      canvas {
        border: 1px solid #ccc;
      }
      button {
        padding: 10px 20px;
        background-color: #007bff;
        color: white;
        border: none;
        cursor: pointer;
      }
      `
    },
    {
      type: "js",
      path: "position.js",
      content: `
      export default class Position {
        constructor(x, y) {
          this.x = x;
          this.y = y;
        }
      }
      `
    },
    {
      type: "js",
      path: "line.js",
      content: `
      import { Position } from './position.js';

      export default class Line {
        constructor(position1, position2) {
          this.position1 = position1;
          this.position2 = position2;
        }
      }
      `
    },
    {
      type: "js",
      path: "index.js",
      content: `
      import "./styles.css";
      import Position from './position.js';
      import Line from './line.js';

      const canvas = document.getElementById('line-4');
      const ctx = canvas.getContext('2d');

      const button = document.getElementById('button');

      canvas.width = 200;
      canvas.height = 200;

      // 좌표를 저장하는 변수
      const positions = [
        new Position(0, 0),
        new Position(0, 0),
        new Position(0, 0),
        new Position(0, 0),
        new Position(0, 0),
      ];

      // 선을 저장하는 변수
      const lines = [
        new Line(positions[0], positions[1]),
        new Line(positions[1], positions[2]),
        new Line(positions[2], positions[3]),
        new Line(positions[3], positions[4]),
        new Line(positions[4], positions[0]),
      ];

      // 좌표를 무작위로 생성하는 함수
      function generateRandomData() {
        positions[0].x = Math.random() * 200;
        positions[0].y = Math.random() * 200;
        positions[1].x = Math.random() * 200;
        positions[1].y = Math.random() * 200;
        positions[2].x = Math.random() * 200;
        positions[2].y = Math.random() * 200;
        positions[3].x = Math.random() * 200;
        positions[3].y = Math.random() * 200;
        positions[4].x = Math.random() * 200;
        positions[4].y = Math.random() * 200;
      }

      // 데이터 생성
      generateRandomData();

      // 라인 데이터 표현
      function drawLine(line) {
        ctx.strokeStyle = 'steelblue';
        ctx.beginPath();
        ctx.lineTo(line.position1.x, 200 - line.position1.y);
        ctx.lineTo(line.position2.x, 200 - line.position2.y);
        ctx.closePath();
        ctx.stroke();
      }

      // 캔버스 랜더링
      function render() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawLine(lines[0]);
        drawLine(lines[1]);
        drawLine(lines[2]);
        drawLine(lines[3]);
        drawLine(lines[4]);
      }

      button.addEventListener('click', () => {
        // 데이터 제어한다.
        generateRandomData();

        // 데이터를 시간화 한다.
        render();
      });

      render();
      `
    }

]}

/>

클라스는 정보만 담고있지 않아도 된다. 우리는 그 정보마다 데이터를 표현하기 때문에 캔버스에 그려지는 함수를 클라스에 넣는것이 바람직하다.
이러한 데이터와 그의 역활에 맞게 함수를 작성하는것을 객체지향 프로그래밍이라고 한다.

객체지향 프로그래밍은 코드의 재사용성을 높이고, 유지보수를 용이하게 하는 중요한 개념이다.

Renderer 클라스를 만들고 렌더링 메소드에 데이터 클라스를 집어넣었을때에, 각 데이터 클라스들이 렌더링 메소드를 호출하는 코드를 작성해보자.
꼭지점을 100개로 늘리고, 선을 100개로 늘렸을때에도 코드가 깔끔하게 잘 작동하는지 보자.

<CodeRunner
  title="선 - 5"
  height={460}
  files={[
    {
      type: "html",
      path: "index.html",
      content: `
      <!DOCTYPE html>
      <html>
        <body>
          <div class="container">
            <h1>선 - 5</h1>
            <canvas id="line-5"></canvas>
            <button id="button">버튼</button>
          </div>
        </body>
      </html>
      `
    },
    {
      type: "css",
      path: "styles.css",
      content: `
      .container {
        padding: 20px;
        text-align: center;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 20px;
      }
      canvas {
        border: 1px solid #ccc;
      }
      button {
        padding: 10px 20px;
        background-color: #007bff;
        color: white;
        border: none;
        cursor: pointer;
      }
      `
    },
    {
      type: "js",
      path: "utils.js",
      content: `
      export function generateRandomValue() {
        return Math.random() * 200;
      }
      `
    },
    {
      type: "js",
      path: "renderer.js",
      content: `
      export default class Renderer {
        constructor(canvas) {
          this.canvas = canvas;
          this.ctx = canvas.getContext('2d');

          this.canvas.width = 200;
          this.canvas.height = 200;
        }

        draw(lines) {
          this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

          lines.forEach(line => {
            line.draw(this.ctx);
          });
        }
      }
      `
    },
    {
      type: "js",
      path: "position.js",
      content: `
      export default class Position {
        constructor(x, y) {
          this.x = x;
          this.y = y;
        }

        // 렌더링 메소드
        draw(ctx) {
          ctx.fillStyle = 'steelblue';
          ctx.beginPath();
          ctx.ellipse(this.x, this.y, 10, 10, 0, 0, 2 * Math.PI);
          ctx.closePath();
          ctx.fill();
        }
      }
      `
    },
    {
      type: "js",
      path: "line.js",
      content: `
      import { Position } from './position.js';

      export default class Line {
        constructor(position1, position2) {
          this.position1 = position1;
          this.position2 = position2;
        }

        // 렌더링 메소드
        draw(ctx) {
          ctx.strokeStyle = 'steelblue';
          ctx.beginPath();
          ctx.lineTo(this.position1.x, 200 - this.position1.y);
          ctx.lineTo(this.position2.x, 200 - this.position2.y);
          ctx.closePath();
          ctx.stroke();
        }
      }
      `
    },
    {
      type: "js",
      path: "index.js",
      content: `
      import "./styles.css";
      import Position from './position.js';
      import Line from './line.js';
      import Renderer from './renderer.js';
      import { generateRandomValue } from './utils.js';

      const canvas = document.getElementById('line-5');

      const button = document.getElementById('button');

      // 렌더러 생성
      const renderer = new Renderer(canvas);


      const POSITION_COUNT = 100;

      // 좌표를 저장하는 변수
      const positions = new Array(POSITION_COUNT).fill(0).map(() => new Position(0, 0));

      // 선을 저장하는 변수
      const lines = new Array(POSITION_COUNT).fill(0).map((_, i) => new Line(positions[i], positions[(i + 1) % positions.length]));

      // 좌표를 무작위로 생성하는 함수
      function generateRandomData() {
        for (let i = 0; i < positions.length; i++) {
          positions[i].x = generateRandomValue();
          positions[i].y = generateRandomValue();
        }
      }

      // 데이터 생성
      button.addEventListener('click', () => {
        // 데이터 제어한다.
        generateRandomData();

        // 데이터를 시간화 한다.
        renderer.draw(lines);
      });

      generateRandomData();
      renderer.draw(lines);
      `
    }

]}

/>

지금 작성한 렌더링 클라스의 역할은 데이터를 그대로 캔버스에 옮겨주는 도우미일 뿐이다.

캔버스의 콘텍스트를 그대로 옮겨 선에게 던져주는 것이다. 어떤 데어터를 표현하는지, 또 그런 데이터를 어떻게 표현하는지는 선의 책임이다.

![/02-lines/figure-01.png](/images/data-visualization/fundamentals/02-lines/figure-01.png "선. 표기-01) 표현처리를 도와주는 도우미 - 랜더링 클라스")

## 마무리

우리는 선을 그려가면서 데이터가 점을 생성하는것보다 많고 복잡해지면 어떻게 코드를 작성해야 깔끔하게 유지할 수 있는지 배워보았다.
데이터와 그 데이터를 표현하는 함수를 클라스에 넣어서 관리하는것이 객체지향 프로그래밍이다.

물론 이러한 방법이 모두 정답이라고는 할 수 없다. 하지만 코드를 작성하면서 점점 생각이 복잡해질때마다, 코드를 분리하고, 재사용성을 높이고, 유지보수를 용이하게 하는 방법을 생각해보자.
데이터와 표현을 분리하는것, 데이터와 데이터 사이를 분리하는것. 그리고 그 분리된 것들을 모아 처리하는 코드를 짜는것.
하나하나 천천히 하다보면 어느세 좋은 코드를 작성할 수 있을것이다.
